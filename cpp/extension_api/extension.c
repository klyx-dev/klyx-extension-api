// Generated by `wit-bindgen` 0.43.0. DO NOT EDIT!
#include "extension.h"
#include <stdlib.h>
#include <string.h>

// Imported Functions from `klyx:extension/system`

__attribute__((__import_module__("klyx:extension/system"), __import_name__("show-toast")))
extern void __wasm_import_klyx_extension_system_show_toast(uint8_t *, size_t, int32_t);

// Imported Functions from `klyx:extension/http-client`

__attribute__((__import_module__("klyx:extension/http-client"), __import_name__("fetch")))
extern void __wasm_import_klyx_extension_http_client_fetch(int32_t, uint8_t *, size_t, uint8_t *, size_t, int32_t, uint8_t *, size_t, int32_t, int32_t, uint8_t *);

__attribute__((__import_module__("klyx:extension/http-client"), __import_name__("[method]http-response-stream.next-chunk")))
extern void __wasm_import_klyx_extension_http_client_method_http_response_stream_next_chunk(int32_t, uint8_t *);

__attribute__((__import_module__("klyx:extension/http-client"), __import_name__("fetch-stream")))
extern void __wasm_import_klyx_extension_http_client_fetch_stream(int32_t, uint8_t *, size_t, uint8_t *, size_t, int32_t, uint8_t *, size_t, int32_t, int32_t, uint8_t *);

// Imported Functions from `klyx:extension/process`

__attribute__((__import_module__("klyx:extension/process"), __import_name__("run-command")))
extern void __wasm_import_klyx_extension_process_run_command(uint8_t *, size_t, uint8_t *, size_t, uint8_t *, size_t, uint8_t *);

// Imported Functions from `extension`

__attribute__((__import_module__("$root"), __import_name__("download-file")))
extern void __wasm_import_extension_download_file(uint8_t *, size_t, uint8_t *, size_t, uint8_t *);

__attribute__((__import_module__("$root"), __import_name__("get-settings")))
extern void __wasm_import_extension_get_settings(int32_t, int64_t, uint8_t *, size_t, uint8_t *, size_t, int32_t, uint8_t *, size_t, uint8_t *);

__attribute__((__import_module__("$root"), __import_name__("make-file-executable")))
extern void __wasm_import_extension_make_file_executable(uint8_t *, size_t, uint8_t *);

__attribute__((__import_module__("$root"), __import_name__("set-language-server-installation-status")))
extern void __wasm_import_extension_set_language_server_installation_status(uint8_t *, size_t, int32_t, uint8_t *, size_t);

__attribute__((__import_module__("$root"), __import_name__("[method]worktree.id")))
extern int64_t __wasm_import_extension_method_worktree_id(int32_t);

__attribute__((__import_module__("$root"), __import_name__("[method]worktree.root-path")))
extern void __wasm_import_extension_method_worktree_root_path(int32_t, uint8_t *);

__attribute__((__import_module__("$root"), __import_name__("[method]worktree.read-text-file")))
extern void __wasm_import_extension_method_worktree_read_text_file(int32_t, uint8_t *, size_t, uint8_t *);

__attribute__((__import_module__("$root"), __import_name__("[method]worktree.which")))
extern void __wasm_import_extension_method_worktree_which(int32_t, uint8_t *, size_t, uint8_t *);

__attribute__((__import_module__("$root"), __import_name__("[method]worktree.shell-env")))
extern void __wasm_import_extension_method_worktree_shell_env(int32_t, uint8_t *);

__attribute__((__import_module__("$root"), __import_name__("[method]project.worktree-ids")))
extern void __wasm_import_extension_method_project_worktree_ids(int32_t, uint8_t *);

__attribute__((__import_module__("$root"), __import_name__("[method]key-value-store.insert")))
extern void __wasm_import_extension_method_key_value_store_insert(int32_t, uint8_t *, size_t, uint8_t *, size_t, uint8_t *);

// Exported Functions from `extension`



__attribute__((__weak__, __export_name__("cabi_post_language-server-command")))
void __wasm_export_exports_extension_language_server_command_post_return(uint8_t * arg0) {
  switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + 0))) {
    case 0: {
      if ((*((size_t*) (arg0 + (2*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + sizeof(void*))));
      }
      size_t len = *((size_t*) (arg0 + (4*sizeof(void*))));
      if (len > 0) {
        uint8_t *ptr = *((uint8_t **) (arg0 + (3*sizeof(void*))));
        for (size_t i = 0; i < len; i++) {
          uint8_t *base = ptr + i * (2*sizeof(void*));
          (void) base;
          if ((*((size_t*) (base + sizeof(void*)))) > 0) {
            free(*((uint8_t **) (base + 0)));
          }
        }
        free(ptr);
      }
      size_t len0 = *((size_t*) (arg0 + (6*sizeof(void*))));
      if (len0 > 0) {
        uint8_t *ptr1 = *((uint8_t **) (arg0 + (5*sizeof(void*))));
        for (size_t i2 = 0; i2 < len0; i2++) {
          uint8_t *base = ptr1 + i2 * (4*sizeof(void*));
          (void) base;
          if ((*((size_t*) (base + sizeof(void*)))) > 0) {
            free(*((uint8_t **) (base + 0)));
          }
          if ((*((size_t*) (base + (3*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (base + (2*sizeof(void*)))));
          }
        }
        free(ptr1);
      }
      break;
    }
    case 1: {
      if ((*((size_t*) (arg0 + (2*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + sizeof(void*))));
      }
      break;
    }
  }
}

__attribute__((__weak__, __export_name__("cabi_post_language-server-initialization-options")))
void __wasm_export_exports_extension_language_server_initialization_options_post_return(uint8_t * arg0) {
  switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + 0))) {
    case 0: {
      switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + sizeof(void*)))) {
        case 0: {
          break;
        }
        case 1: {
          if ((*((size_t*) (arg0 + (3*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (arg0 + (2*sizeof(void*)))));
          }
          break;
        }
      }
      break;
    }
    case 1: {
      if ((*((size_t*) (arg0 + (2*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + sizeof(void*))));
      }
      break;
    }
  }
}

__attribute__((__weak__, __export_name__("cabi_post_language-server-workspace-configuration")))
void __wasm_export_exports_extension_language_server_workspace_configuration_post_return(uint8_t * arg0) {
  switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + 0))) {
    case 0: {
      switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + sizeof(void*)))) {
        case 0: {
          break;
        }
        case 1: {
          if ((*((size_t*) (arg0 + (3*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (arg0 + (2*sizeof(void*)))));
          }
          break;
        }
      }
      break;
    }
    case 1: {
      if ((*((size_t*) (arg0 + (2*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + sizeof(void*))));
      }
      break;
    }
  }
}

__attribute__((__weak__, __export_name__("cabi_post_language-server-additional-initialization-options")))
void __wasm_export_exports_extension_language_server_additional_initialization_options_post_return(uint8_t * arg0) {
  switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + 0))) {
    case 0: {
      switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + sizeof(void*)))) {
        case 0: {
          break;
        }
        case 1: {
          if ((*((size_t*) (arg0 + (3*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (arg0 + (2*sizeof(void*)))));
          }
          break;
        }
      }
      break;
    }
    case 1: {
      if ((*((size_t*) (arg0 + (2*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + sizeof(void*))));
      }
      break;
    }
  }
}

__attribute__((__weak__, __export_name__("cabi_post_language-server-additional-workspace-configuration")))
void __wasm_export_exports_extension_language_server_additional_workspace_configuration_post_return(uint8_t * arg0) {
  switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + 0))) {
    case 0: {
      switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + sizeof(void*)))) {
        case 0: {
          break;
        }
        case 1: {
          if ((*((size_t*) (arg0 + (3*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (arg0 + (2*sizeof(void*)))));
          }
          break;
        }
      }
      break;
    }
    case 1: {
      if ((*((size_t*) (arg0 + (2*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + sizeof(void*))));
      }
      break;
    }
  }
}

__attribute__((__weak__, __export_name__("cabi_post_labels-for-completions")))
void __wasm_export_exports_extension_labels_for_completions_post_return(uint8_t * arg0) {
  switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + 0))) {
    case 0: {
      size_t len0 = *((size_t*) (arg0 + (2*sizeof(void*))));
      if (len0 > 0) {
        uint8_t *ptr1 = *((uint8_t **) (arg0 + sizeof(void*)));
        for (size_t i2 = 0; i2 < len0; i2++) {
          uint8_t *base = ptr1 + i2 * (8+5*sizeof(void*));
          (void) base;
          switch ((int32_t) (int32_t) *((uint8_t*) (base + 0))) {
            case 0: {
              break;
            }
            case 1: {
              if ((*((size_t*) (base + (2*sizeof(void*))))) > 0) {
                free(*((uint8_t **) (base + sizeof(void*))));
              }
              size_t len = *((size_t*) (base + (4*sizeof(void*))));
              if (len > 0) {
                uint8_t *ptr = *((uint8_t **) (base + (3*sizeof(void*))));
                for (size_t i = 0; i < len; i++) {
                  uint8_t *base = ptr + i * (6*sizeof(void*));
                  (void) base;
                  switch ((int32_t) (int32_t) *((uint8_t*) (base + 0))) {
                    case 0: {
                      break;
                    }
                    case 1: {
                      if ((*((size_t*) (base + (2*sizeof(void*))))) > 0) {
                        free(*((uint8_t **) (base + sizeof(void*))));
                      }
                      switch ((int32_t) (int32_t) *((uint8_t*) (base + (3*sizeof(void*))))) {
                        case 0: {
                          break;
                        }
                        case 1: {
                          if ((*((size_t*) (base + (5*sizeof(void*))))) > 0) {
                            free(*((uint8_t **) (base + (4*sizeof(void*)))));
                          }
                          break;
                        }
                      }
                      break;
                    }
                  }
                }
                free(ptr);
              }
              break;
            }
          }
        }
        free(ptr1);
      }
      break;
    }
    case 1: {
      if ((*((size_t*) (arg0 + (2*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + sizeof(void*))));
      }
      break;
    }
  }
}

__attribute__((__weak__, __export_name__("cabi_post_labels-for-symbols")))
void __wasm_export_exports_extension_labels_for_symbols_post_return(uint8_t * arg0) {
  switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + 0))) {
    case 0: {
      size_t len0 = *((size_t*) (arg0 + (2*sizeof(void*))));
      if (len0 > 0) {
        uint8_t *ptr1 = *((uint8_t **) (arg0 + sizeof(void*)));
        for (size_t i2 = 0; i2 < len0; i2++) {
          uint8_t *base = ptr1 + i2 * (8+5*sizeof(void*));
          (void) base;
          switch ((int32_t) (int32_t) *((uint8_t*) (base + 0))) {
            case 0: {
              break;
            }
            case 1: {
              if ((*((size_t*) (base + (2*sizeof(void*))))) > 0) {
                free(*((uint8_t **) (base + sizeof(void*))));
              }
              size_t len = *((size_t*) (base + (4*sizeof(void*))));
              if (len > 0) {
                uint8_t *ptr = *((uint8_t **) (base + (3*sizeof(void*))));
                for (size_t i = 0; i < len; i++) {
                  uint8_t *base = ptr + i * (6*sizeof(void*));
                  (void) base;
                  switch ((int32_t) (int32_t) *((uint8_t*) (base + 0))) {
                    case 0: {
                      break;
                    }
                    case 1: {
                      if ((*((size_t*) (base + (2*sizeof(void*))))) > 0) {
                        free(*((uint8_t **) (base + sizeof(void*))));
                      }
                      switch ((int32_t) (int32_t) *((uint8_t*) (base + (3*sizeof(void*))))) {
                        case 0: {
                          break;
                        }
                        case 1: {
                          if ((*((size_t*) (base + (5*sizeof(void*))))) > 0) {
                            free(*((uint8_t **) (base + (4*sizeof(void*)))));
                          }
                          break;
                        }
                      }
                      break;
                    }
                  }
                }
                free(ptr);
              }
              break;
            }
          }
        }
        free(ptr1);
      }
      break;
    }
    case 1: {
      if ((*((size_t*) (arg0 + (2*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + sizeof(void*))));
      }
      break;
    }
  }
}

// Canonical ABI intrinsics

__attribute__((__weak__, __export_name__("cabi_realloc")))
void *cabi_realloc(void *ptr, size_t old_size, size_t align, size_t new_size) {
  (void) old_size;
  if (new_size == 0) return (void*) align;
  void *ret = realloc(ptr, new_size);
  if (!ret) abort();
  return ret;
}

__attribute__((__aligned__(sizeof(void*))))
static uint8_t RET_AREA[(7*sizeof(void*))];

// Helper Functions

void klyx_extension_http_client_redirect_policy_free(klyx_extension_http_client_redirect_policy_t *ptr) {
  switch ((int32_t) ptr->tag) {
    case 1: {
      break;
    }
  }
}

void extension_tuple2_string_string_free(extension_tuple2_string_string_t *ptr) {
  extension_string_free(&ptr->f0);
  extension_string_free(&ptr->f1);
}

void extension_list_tuple2_string_string_free(extension_list_tuple2_string_string_t *ptr) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    extension_tuple2_string_string_t *list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
      extension_tuple2_string_string_free(&list_ptr[i]);
    }
    free(list_ptr);
  }
}

void extension_list_u8_free(extension_list_u8_t *ptr) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    uint8_t *list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
    }
    free(list_ptr);
  }
}

void extension_option_list_u8_free(extension_option_list_u8_t *ptr) {
  if (ptr->is_some) {
    extension_list_u8_free(&ptr->val);
  }
}

void klyx_extension_http_client_http_request_free(klyx_extension_http_client_http_request_t *ptr) {
  extension_string_free(&ptr->url);
  extension_list_tuple2_string_string_free(&ptr->headers);
  extension_option_list_u8_free(&ptr->body);
  klyx_extension_http_client_redirect_policy_free(&ptr->redirect_policy);
}

void klyx_extension_http_client_http_response_free(klyx_extension_http_client_http_response_t *ptr) {
  extension_list_tuple2_string_string_free(&ptr->headers);
  extension_list_u8_free(&ptr->body);
}

__attribute__((__import_module__("klyx:extension/http-client"), __import_name__("[resource-drop]http-response-stream")))
extern void __wasm_import_klyx_extension_http_client_http_response_stream_drop(int32_t handle);

void klyx_extension_http_client_http_response_stream_drop_own(klyx_extension_http_client_own_http_response_stream_t handle) {
  __wasm_import_klyx_extension_http_client_http_response_stream_drop(handle.__handle);
}

void klyx_extension_http_client_http_response_stream_drop_borrow(klyx_extension_http_client_borrow_http_response_stream_t handle) {
  __wasm_import_klyx_extension_http_client_http_response_stream_drop(handle.__handle);
}

klyx_extension_http_client_borrow_http_response_stream_t klyx_extension_http_client_borrow_http_response_stream(klyx_extension_http_client_own_http_response_stream_t arg) {
  return (klyx_extension_http_client_borrow_http_response_stream_t) { arg.__handle };
}

void klyx_extension_http_client_result_http_response_string_free(klyx_extension_http_client_result_http_response_string_t *ptr) {
  if (!ptr->is_err) {
    klyx_extension_http_client_http_response_free(&ptr->val.ok);
  } else {
    extension_string_free(&ptr->val.err);
  }
}

void klyx_extension_http_client_result_option_list_u8_string_free(klyx_extension_http_client_result_option_list_u8_string_t *ptr) {
  if (!ptr->is_err) {
    extension_option_list_u8_free(&ptr->val.ok);
  } else {
    extension_string_free(&ptr->val.err);
  }
}

void klyx_extension_http_client_result_own_http_response_stream_string_free(klyx_extension_http_client_result_own_http_response_stream_string_t *ptr) {
  if (!ptr->is_err) {
  } else {
    extension_string_free(&ptr->val.err);
  }
}

void klyx_extension_common_env_vars_free(klyx_extension_common_env_vars_t *ptr) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    extension_tuple2_string_string_t *list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
      extension_tuple2_string_string_free(&list_ptr[i]);
    }
    free(list_ptr);
  }
}

void klyx_extension_process_env_vars_free(klyx_extension_process_env_vars_t *ptr) {
  klyx_extension_common_env_vars_free(ptr);
}

void extension_list_string_free(extension_list_string_t *ptr) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    extension_string_t *list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
      extension_string_free(&list_ptr[i]);
    }
    free(list_ptr);
  }
}

void klyx_extension_process_command_free(klyx_extension_process_command_t *ptr) {
  extension_string_free(&ptr->command);
  extension_list_string_free(&ptr->args);
  klyx_extension_process_env_vars_free(&ptr->env);
}

void extension_option_s32_free(extension_option_s32_t *ptr) {
  if (ptr->is_some) {
  }
}

void klyx_extension_process_output_free(klyx_extension_process_output_t *ptr) {
  extension_option_s32_free(&ptr->status);
  extension_list_u8_free(&ptr->stdout);
  extension_list_u8_free(&ptr->stderr);
}

void klyx_extension_process_result_output_string_free(klyx_extension_process_result_output_string_t *ptr) {
  if (!ptr->is_err) {
    klyx_extension_process_output_free(&ptr->val.ok);
  } else {
    extension_string_free(&ptr->val.err);
  }
}

void klyx_extension_lsp_completion_kind_free(klyx_extension_lsp_completion_kind_t *ptr) {
  switch ((int32_t) ptr->tag) {
    case 25: {
      break;
    }
  }
}

void extension_option_string_free(extension_option_string_t *ptr) {
  if (ptr->is_some) {
    extension_string_free(&ptr->val);
  }
}

void klyx_extension_lsp_completion_label_details_free(klyx_extension_lsp_completion_label_details_t *ptr) {
  extension_option_string_free(&ptr->detail);
  extension_option_string_free(&ptr->description);
}

void klyx_extension_lsp_insert_text_format_free(klyx_extension_lsp_insert_text_format_t *ptr) {
  switch ((int32_t) ptr->tag) {
    case 2: {
      break;
    }
  }
}

void klyx_extension_lsp_option_completion_label_details_free(klyx_extension_lsp_option_completion_label_details_t *ptr) {
  if (ptr->is_some) {
    klyx_extension_lsp_completion_label_details_free(&ptr->val);
  }
}

void klyx_extension_lsp_option_completion_kind_free(klyx_extension_lsp_option_completion_kind_t *ptr) {
  if (ptr->is_some) {
    klyx_extension_lsp_completion_kind_free(&ptr->val);
  }
}

void klyx_extension_lsp_option_insert_text_format_free(klyx_extension_lsp_option_insert_text_format_t *ptr) {
  if (ptr->is_some) {
    klyx_extension_lsp_insert_text_format_free(&ptr->val);
  }
}

void klyx_extension_lsp_completion_free(klyx_extension_lsp_completion_t *ptr) {
  extension_string_free(&ptr->label);
  klyx_extension_lsp_option_completion_label_details_free(&ptr->label_details);
  extension_option_string_free(&ptr->detail);
  klyx_extension_lsp_option_completion_kind_free(&ptr->kind);
  klyx_extension_lsp_option_insert_text_format_free(&ptr->insert_text_format);
}

void klyx_extension_lsp_symbol_kind_free(klyx_extension_lsp_symbol_kind_t *ptr) {
  switch ((int32_t) ptr->tag) {
    case 26: {
      break;
    }
  }
}

void klyx_extension_lsp_symbol_free(klyx_extension_lsp_symbol_t *ptr) {
  klyx_extension_lsp_symbol_kind_free(&ptr->kind);
  extension_string_free(&ptr->name);
}

void extension_env_vars_free(extension_env_vars_t *ptr) {
  klyx_extension_common_env_vars_free(ptr);
}

void extension_completion_free(extension_completion_t *ptr) {
  klyx_extension_lsp_completion_free(ptr);
}

void extension_symbol_free(extension_symbol_t *ptr) {
  klyx_extension_lsp_symbol_free(ptr);
}

void extension_command_free(extension_command_t *ptr) {
  klyx_extension_process_command_free(ptr);
}

void extension_language_server_installation_status_free(extension_language_server_installation_status_t *ptr) {
  switch ((int32_t) ptr->tag) {
    case 3: {
      extension_string_free(&ptr->val.failed);
      break;
    }
  }
}

void extension_settings_location_free(extension_settings_location_t *ptr) {
  extension_string_free(&ptr->path);
}

__attribute__((__import_module__("$root"), __import_name__("[resource-drop]worktree")))
extern void __wasm_import_extension_worktree_drop(int32_t handle);

void extension_worktree_drop_own(extension_own_worktree_t handle) {
  __wasm_import_extension_worktree_drop(handle.__handle);
}

void extension_worktree_drop_borrow(extension_borrow_worktree_t handle) {
  __wasm_import_extension_worktree_drop(handle.__handle);
}

extension_borrow_worktree_t extension_borrow_worktree(extension_own_worktree_t arg) {
  return (extension_borrow_worktree_t) { arg.__handle };
}

__attribute__((__import_module__("$root"), __import_name__("[resource-drop]project")))
extern void __wasm_import_extension_project_drop(int32_t handle);

void extension_project_drop_own(extension_own_project_t handle) {
  __wasm_import_extension_project_drop(handle.__handle);
}

void extension_project_drop_borrow(extension_borrow_project_t handle) {
  __wasm_import_extension_project_drop(handle.__handle);
}

extension_borrow_project_t extension_borrow_project(extension_own_project_t arg) {
  return (extension_borrow_project_t) { arg.__handle };
}

__attribute__((__import_module__("$root"), __import_name__("[resource-drop]key-value-store")))
extern void __wasm_import_extension_key_value_store_drop(int32_t handle);

void extension_key_value_store_drop_own(extension_own_key_value_store_t handle) {
  __wasm_import_extension_key_value_store_drop(handle.__handle);
}

void extension_key_value_store_drop_borrow(extension_borrow_key_value_store_t handle) {
  __wasm_import_extension_key_value_store_drop(handle.__handle);
}

extension_borrow_key_value_store_t extension_borrow_key_value_store(extension_own_key_value_store_t arg) {
  return (extension_borrow_key_value_store_t) { arg.__handle };
}

void extension_code_label_span_literal_free(extension_code_label_span_literal_t *ptr) {
  extension_string_free(&ptr->text);
  extension_option_string_free(&ptr->highlight_name);
}

void extension_code_label_span_free(extension_code_label_span_t *ptr) {
  switch ((int32_t) ptr->tag) {
    case 0: {
      break;
    }
    case 1: {
      extension_code_label_span_literal_free(&ptr->val.literal);
      break;
    }
  }
}

void extension_list_code_label_span_free(extension_list_code_label_span_t *ptr) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    extension_code_label_span_t *list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
      extension_code_label_span_free(&list_ptr[i]);
    }
    free(list_ptr);
  }
}

void extension_code_label_free(extension_code_label_t *ptr) {
  extension_string_free(&ptr->code);
  extension_list_code_label_span_free(&ptr->spans);
}

void extension_result_void_string_free(extension_result_void_string_t *ptr) {
  if (!ptr->is_err) {
  } else {
    extension_string_free(&ptr->val.err);
  }
}

void extension_option_settings_location_free(extension_option_settings_location_t *ptr) {
  if (ptr->is_some) {
    extension_settings_location_free(&ptr->val);
  }
}

void extension_result_string_string_free(extension_result_string_string_t *ptr) {
  if (!ptr->is_err) {
    extension_string_free(&ptr->val.ok);
  } else {
    extension_string_free(&ptr->val.err);
  }
}

void extension_list_u64_free(extension_list_u64_t *ptr) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    uint64_t *list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
    }
    free(list_ptr);
  }
}

void extension_result_command_string_free(extension_result_command_string_t *ptr) {
  if (!ptr->is_err) {
    extension_command_free(&ptr->val.ok);
  } else {
    extension_string_free(&ptr->val.err);
  }
}

void extension_result_option_string_string_free(extension_result_option_string_string_t *ptr) {
  if (!ptr->is_err) {
    extension_option_string_free(&ptr->val.ok);
  } else {
    extension_string_free(&ptr->val.err);
  }
}

void extension_list_completion_free(extension_list_completion_t *ptr) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    extension_completion_t *list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
      extension_completion_free(&list_ptr[i]);
    }
    free(list_ptr);
  }
}

void extension_option_code_label_free(extension_option_code_label_t *ptr) {
  if (ptr->is_some) {
    extension_code_label_free(&ptr->val);
  }
}

void extension_list_option_code_label_free(extension_list_option_code_label_t *ptr) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    extension_option_code_label_t *list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
      extension_option_code_label_free(&list_ptr[i]);
    }
    free(list_ptr);
  }
}

void extension_result_list_option_code_label_string_free(extension_result_list_option_code_label_string_t *ptr) {
  if (!ptr->is_err) {
    extension_list_option_code_label_free(&ptr->val.ok);
  } else {
    extension_string_free(&ptr->val.err);
  }
}

void extension_list_symbol_free(extension_list_symbol_t *ptr) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    extension_symbol_t *list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
      extension_symbol_free(&list_ptr[i]);
    }
    free(list_ptr);
  }
}

void extension_string_set(extension_string_t *ret, const char*s) {
  ret->ptr = (uint8_t*) s;
  ret->len = strlen(s);
}

void extension_string_dup(extension_string_t *ret, const char*s) {
  ret->len = strlen(s);
  ret->ptr = (uint8_t*) cabi_realloc(NULL, 0, 1, ret->len * 1);
  memcpy(ret->ptr, s, ret->len * 1);
}

void extension_string_free(extension_string_t *ret) {
  if (ret->len > 0) {
    free(ret->ptr);
  }
  ret->ptr = NULL;
  ret->len = 0;
}

// Component Adapters

void klyx_extension_system_show_toast(extension_string_t *message, klyx_extension_system_toast_duration_t duration) {
  __wasm_import_klyx_extension_system_show_toast((uint8_t *) (*message).ptr, (*message).len, (int32_t) duration);
}

bool klyx_extension_http_client_fetch(klyx_extension_http_client_http_request_t *req, klyx_extension_http_client_http_response_t *ret, extension_string_t *err) {
  __attribute__((__aligned__(sizeof(void*))))
  uint8_t ret_area[(5*sizeof(void*))];
  int32_t option;
  uint8_t * option1;
  size_t option2;
  if (((*req).body).is_some) {
    const extension_list_u8_t *payload0 = &((*req).body).val;
    option = 1;
    option1 = (uint8_t *) (*payload0).ptr;
    option2 = (*payload0).len;
  } else {
    option = 0;
    option1 = 0;
    option2 = 0;
  }
  int32_t variant;
  int32_t variant6;
  switch ((int32_t) ((*req).redirect_policy).tag) {
    case 0: {
      variant = 0;
      variant6 = 0;
      break;
    }
    case 1: {
      const uint32_t *payload4 = &((*req).redirect_policy).val.follow_limit;
      variant = 1;
      variant6 = (int32_t) (*payload4);
      break;
    }
    case 2: {
      variant = 2;
      variant6 = 0;
      break;
    }
  }
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_klyx_extension_http_client_fetch((int32_t) (*req).method, (uint8_t *) ((*req).url).ptr, ((*req).url).len, (uint8_t *) ((*req).headers).ptr, ((*req).headers).len, option, option1, option2, variant, variant6, ptr);
  klyx_extension_http_client_result_http_response_string_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (klyx_extension_http_client_http_response_t) {
        (extension_list_tuple2_string_string_t) (extension_list_tuple2_string_string_t) { (extension_tuple2_string_string_t*)(*((uint8_t **) (ptr + sizeof(void*)))), (*((size_t*) (ptr + (2*sizeof(void*))))) },
        (extension_list_u8_t) (extension_list_u8_t) { (uint8_t*)(*((uint8_t **) (ptr + (3*sizeof(void*))))), (*((size_t*) (ptr + (4*sizeof(void*))))) },
      };
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (extension_string_t) { (uint8_t*)(*((uint8_t **) (ptr + sizeof(void*)))), (*((size_t*) (ptr + (2*sizeof(void*))))) };
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool klyx_extension_http_client_method_http_response_stream_next_chunk(klyx_extension_http_client_borrow_http_response_stream_t self, extension_option_list_u8_t *ret, extension_string_t *err) {
  __attribute__((__aligned__(sizeof(void*))))
  uint8_t ret_area[(4*sizeof(void*))];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_klyx_extension_http_client_method_http_response_stream_next_chunk((self).__handle, ptr);
  klyx_extension_http_client_result_option_list_u8_string_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      extension_option_list_u8_t option;
      switch ((int32_t) *((uint8_t*) (ptr + sizeof(void*)))) {
        case 0: {
          option.is_some = false;
          break;
        }
        case 1: {
          option.is_some = true;
          option.val = (extension_list_u8_t) { (uint8_t*)(*((uint8_t **) (ptr + (2*sizeof(void*))))), (*((size_t*) (ptr + (3*sizeof(void*))))) };
          break;
        }
      }

      result.val.ok = option;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (extension_string_t) { (uint8_t*)(*((uint8_t **) (ptr + sizeof(void*)))), (*((size_t*) (ptr + (2*sizeof(void*))))) };
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool klyx_extension_http_client_fetch_stream(klyx_extension_http_client_http_request_t *req, klyx_extension_http_client_own_http_response_stream_t *ret, extension_string_t *err) {
  __attribute__((__aligned__(sizeof(void*))))
  uint8_t ret_area[(3*sizeof(void*))];
  int32_t option;
  uint8_t * option1;
  size_t option2;
  if (((*req).body).is_some) {
    const extension_list_u8_t *payload0 = &((*req).body).val;
    option = 1;
    option1 = (uint8_t *) (*payload0).ptr;
    option2 = (*payload0).len;
  } else {
    option = 0;
    option1 = 0;
    option2 = 0;
  }
  int32_t variant;
  int32_t variant6;
  switch ((int32_t) ((*req).redirect_policy).tag) {
    case 0: {
      variant = 0;
      variant6 = 0;
      break;
    }
    case 1: {
      const uint32_t *payload4 = &((*req).redirect_policy).val.follow_limit;
      variant = 1;
      variant6 = (int32_t) (*payload4);
      break;
    }
    case 2: {
      variant = 2;
      variant6 = 0;
      break;
    }
  }
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_klyx_extension_http_client_fetch_stream((int32_t) (*req).method, (uint8_t *) ((*req).url).ptr, ((*req).url).len, (uint8_t *) ((*req).headers).ptr, ((*req).headers).len, option, option1, option2, variant, variant6, ptr);
  klyx_extension_http_client_result_own_http_response_stream_string_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (klyx_extension_http_client_own_http_response_stream_t) { *((int32_t*) (ptr + sizeof(void*))) };
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (extension_string_t) { (uint8_t*)(*((uint8_t **) (ptr + sizeof(void*)))), (*((size_t*) (ptr + (2*sizeof(void*))))) };
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool klyx_extension_process_run_command(klyx_extension_process_command_t *command, klyx_extension_process_output_t *ret, extension_string_t *err) {
  __attribute__((__aligned__(sizeof(void*))))
  uint8_t ret_area[(8+5*sizeof(void*))];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_klyx_extension_process_run_command((uint8_t *) ((*command).command).ptr, ((*command).command).len, (uint8_t *) ((*command).args).ptr, ((*command).args).len, (uint8_t *) ((*command).env).ptr, ((*command).env).len, ptr);
  klyx_extension_process_result_output_string_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      extension_option_s32_t option;
      switch ((int32_t) *((uint8_t*) (ptr + sizeof(void*)))) {
        case 0: {
          option.is_some = false;
          break;
        }
        case 1: {
          option.is_some = true;
          option.val = *((int32_t*) (ptr + (4+1*sizeof(void*))));
          break;
        }
      }

      result.val.ok = (klyx_extension_process_output_t) {
        (extension_option_s32_t) option,
        (extension_list_u8_t) (extension_list_u8_t) { (uint8_t*)(*((uint8_t **) (ptr + (8+1*sizeof(void*))))), (*((size_t*) (ptr + (8+2*sizeof(void*))))) },
        (extension_list_u8_t) (extension_list_u8_t) { (uint8_t*)(*((uint8_t **) (ptr + (8+3*sizeof(void*))))), (*((size_t*) (ptr + (8+4*sizeof(void*))))) },
      };
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (extension_string_t) { (uint8_t*)(*((uint8_t **) (ptr + sizeof(void*)))), (*((size_t*) (ptr + (2*sizeof(void*))))) };
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool extension_download_file(extension_string_t *url, extension_string_t *file_path, extension_string_t *err) {
  __attribute__((__aligned__(sizeof(void*))))
  uint8_t ret_area[(3*sizeof(void*))];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_extension_download_file((uint8_t *) (*url).ptr, (*url).len, (uint8_t *) (*file_path).ptr, (*file_path).len, ptr);
  extension_result_void_string_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (extension_string_t) { (uint8_t*)(*((uint8_t **) (ptr + sizeof(void*)))), (*((size_t*) (ptr + (2*sizeof(void*))))) };
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool extension_get_settings(extension_settings_location_t *maybe_path, extension_string_t *category, extension_string_t *maybe_key, extension_string_t *ret, extension_string_t *err) {
  __attribute__((__aligned__(sizeof(void*))))
  uint8_t ret_area[(3*sizeof(void*))];
  extension_option_settings_location_t path;
  path.is_some = maybe_path != NULL;if (maybe_path) {
    path.val = *maybe_path;
  }
  extension_option_string_t key;
  key.is_some = maybe_key != NULL;if (maybe_key) {
    key.val = *maybe_key;
  }
  int32_t option;
  int64_t option1;
  uint8_t * option2;
  size_t option3;
  if ((path).is_some) {
    const extension_settings_location_t *payload0 = &(path).val;
    option = 1;
    option1 = (int64_t) ((*payload0).worktree_id);
    option2 = (uint8_t *) ((*payload0).path).ptr;
    option3 = ((*payload0).path).len;
  } else {
    option = 0;
    option1 = 0;
    option2 = 0;
    option3 = 0;
  }
  int32_t option6;
  uint8_t * option7;
  size_t option8;
  if ((key).is_some) {
    const extension_string_t *payload5 = &(key).val;
    option6 = 1;
    option7 = (uint8_t *) (*payload5).ptr;
    option8 = (*payload5).len;
  } else {
    option6 = 0;
    option7 = 0;
    option8 = 0;
  }
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_extension_get_settings(option, option1, option2, option3, (uint8_t *) (*category).ptr, (*category).len, option6, option7, option8, ptr);
  extension_result_string_string_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (extension_string_t) { (uint8_t*)(*((uint8_t **) (ptr + sizeof(void*)))), (*((size_t*) (ptr + (2*sizeof(void*))))) };
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (extension_string_t) { (uint8_t*)(*((uint8_t **) (ptr + sizeof(void*)))), (*((size_t*) (ptr + (2*sizeof(void*))))) };
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool extension_make_file_executable(extension_string_t *filepath, extension_string_t *err) {
  __attribute__((__aligned__(sizeof(void*))))
  uint8_t ret_area[(3*sizeof(void*))];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_extension_make_file_executable((uint8_t *) (*filepath).ptr, (*filepath).len, ptr);
  extension_result_void_string_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (extension_string_t) { (uint8_t*)(*((uint8_t **) (ptr + sizeof(void*)))), (*((size_t*) (ptr + (2*sizeof(void*))))) };
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

void extension_set_language_server_installation_status(extension_string_t *language_server_name, extension_language_server_installation_status_t *status) {
  int32_t variant;
  uint8_t * variant3;
  size_t variant4;
  switch ((int32_t) (*status).tag) {
    case 0: {
      variant = 0;
      variant3 = 0;
      variant4 = 0;
      break;
    }
    case 1: {
      variant = 1;
      variant3 = 0;
      variant4 = 0;
      break;
    }
    case 2: {
      variant = 2;
      variant3 = 0;
      variant4 = 0;
      break;
    }
    case 3: {
      const extension_string_t *payload2 = &(*status).val.failed;
      variant = 3;
      variant3 = (uint8_t *) (*payload2).ptr;
      variant4 = (*payload2).len;
      break;
    }
  }
  __wasm_import_extension_set_language_server_installation_status((uint8_t *) (*language_server_name).ptr, (*language_server_name).len, variant, variant3, variant4);
}

uint64_t extension_method_worktree_id(extension_borrow_worktree_t self) {
  int64_t ret = __wasm_import_extension_method_worktree_id((self).__handle);
  return (uint64_t) (ret);
}

void extension_method_worktree_root_path(extension_borrow_worktree_t self, extension_string_t *ret) {
  __attribute__((__aligned__(sizeof(void*))))
  uint8_t ret_area[(2*sizeof(void*))];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_extension_method_worktree_root_path((self).__handle, ptr);
  *ret = (extension_string_t) { (uint8_t*)(*((uint8_t **) (ptr + 0))), (*((size_t*) (ptr + sizeof(void*)))) };
}

bool extension_method_worktree_read_text_file(extension_borrow_worktree_t self, extension_string_t *path, extension_string_t *ret, extension_string_t *err) {
  __attribute__((__aligned__(sizeof(void*))))
  uint8_t ret_area[(3*sizeof(void*))];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_extension_method_worktree_read_text_file((self).__handle, (uint8_t *) (*path).ptr, (*path).len, ptr);
  extension_result_string_string_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (extension_string_t) { (uint8_t*)(*((uint8_t **) (ptr + sizeof(void*)))), (*((size_t*) (ptr + (2*sizeof(void*))))) };
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (extension_string_t) { (uint8_t*)(*((uint8_t **) (ptr + sizeof(void*)))), (*((size_t*) (ptr + (2*sizeof(void*))))) };
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

bool extension_method_worktree_which(extension_borrow_worktree_t self, extension_string_t *binary_name, extension_string_t *ret) {
  __attribute__((__aligned__(sizeof(void*))))
  uint8_t ret_area[(3*sizeof(void*))];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_extension_method_worktree_which((self).__handle, (uint8_t *) (*binary_name).ptr, (*binary_name).len, ptr);
  extension_option_string_t option;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      option.is_some = false;
      break;
    }
    case 1: {
      option.is_some = true;
      option.val = (extension_string_t) { (uint8_t*)(*((uint8_t **) (ptr + sizeof(void*)))), (*((size_t*) (ptr + (2*sizeof(void*))))) };
      break;
    }
  }
  *ret = option.val;
  return option.is_some;
}

void extension_method_worktree_shell_env(extension_borrow_worktree_t self, extension_env_vars_t *ret) {
  __attribute__((__aligned__(sizeof(void*))))
  uint8_t ret_area[(2*sizeof(void*))];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_extension_method_worktree_shell_env((self).__handle, ptr);
  *ret = (klyx_extension_common_env_vars_t) { (extension_tuple2_string_string_t*)(*((uint8_t **) (ptr + 0))), (*((size_t*) (ptr + sizeof(void*)))) };
}

void extension_method_project_worktree_ids(extension_borrow_project_t self, extension_list_u64_t *ret) {
  __attribute__((__aligned__(sizeof(void*))))
  uint8_t ret_area[(2*sizeof(void*))];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_extension_method_project_worktree_ids((self).__handle, ptr);
  *ret = (extension_list_u64_t) { (uint64_t*)(*((uint8_t **) (ptr + 0))), (*((size_t*) (ptr + sizeof(void*)))) };
}

bool extension_method_key_value_store_insert(extension_borrow_key_value_store_t self, extension_string_t *key, extension_string_t *value, extension_string_t *err) {
  __attribute__((__aligned__(sizeof(void*))))
  uint8_t ret_area[(3*sizeof(void*))];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_extension_method_key_value_store_insert((self).__handle, (uint8_t *) (*key).ptr, (*key).len, (uint8_t *) (*value).ptr, (*value).len, ptr);
  extension_result_void_string_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (extension_string_t) { (uint8_t*)(*((uint8_t **) (ptr + sizeof(void*)))), (*((size_t*) (ptr + (2*sizeof(void*))))) };
      break;
    }
  }
  if (!result.is_err) {
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

__attribute__((__export_name__("init-extension")))
void __wasm_export_exports_extension_init_extension(void) {
  exports_extension_init_extension();
}

__attribute__((__export_name__("uninstall")))
void __wasm_export_exports_extension_uninstall(void) {
  exports_extension_uninstall();
}

__attribute__((__export_name__("language-server-command")))
uint8_t * __wasm_export_exports_extension_language_server_command(uint8_t * arg, size_t arg0, int32_t arg1) {
  extension_string_t arg2 = (extension_string_t) { (uint8_t*)(arg), (arg0) };
  extension_result_command_string_t ret;
  extension_command_t ok;
  extension_string_t err;
  ret.is_err = !exports_extension_language_server_command(&arg2, (extension_borrow_worktree_t) { arg1 }, &ok, &err);
  if (ret.is_err) {
    ret.val.err = err;
  }
  if (!ret.is_err) {
    ret.val.ok = ok;
  }
  uint8_t *ptr = (uint8_t *) &RET_AREA;
  if ((ret).is_err) {
    const extension_string_t *payload3 = &(ret).val.err;*((int8_t*)(ptr + 0)) = 1;
    *((size_t*)(ptr + (2*sizeof(void*)))) = (*payload3).len;
    *((uint8_t **)(ptr + sizeof(void*))) = (uint8_t *) (*payload3).ptr;
  } else {
    const extension_command_t *payload = &(ret).val.ok;*((int8_t*)(ptr + 0)) = 0;
    *((size_t*)(ptr + (2*sizeof(void*)))) = ((*payload).command).len;
    *((uint8_t **)(ptr + sizeof(void*))) = (uint8_t *) ((*payload).command).ptr;
    *((size_t*)(ptr + (4*sizeof(void*)))) = ((*payload).args).len;
    *((uint8_t **)(ptr + (3*sizeof(void*)))) = (uint8_t *) ((*payload).args).ptr;
    *((size_t*)(ptr + (6*sizeof(void*)))) = ((*payload).env).len;
    *((uint8_t **)(ptr + (5*sizeof(void*)))) = (uint8_t *) ((*payload).env).ptr;
  }
  return ptr;
}

__attribute__((__export_name__("language-server-initialization-options")))
uint8_t * __wasm_export_exports_extension_language_server_initialization_options(uint8_t * arg, size_t arg0, int32_t arg1) {
  extension_string_t arg2 = (extension_string_t) { (uint8_t*)(arg), (arg0) };
  extension_result_option_string_string_t ret;
  extension_option_string_t ok;
  extension_string_t err;
  ret.is_err = !exports_extension_language_server_initialization_options(&arg2, (extension_borrow_worktree_t) { arg1 }, &ok, &err);
  if (ret.is_err) {
    ret.val.err = err;
  }
  if (!ret.is_err) {
    ret.val.ok = ok;
  }
  uint8_t *ptr = (uint8_t *) &RET_AREA;
  if ((ret).is_err) {
    const extension_string_t *payload5 = &(ret).val.err;*((int8_t*)(ptr + 0)) = 1;
    *((size_t*)(ptr + (2*sizeof(void*)))) = (*payload5).len;
    *((uint8_t **)(ptr + sizeof(void*))) = (uint8_t *) (*payload5).ptr;
  } else {
    const extension_option_string_t *payload = &(ret).val.ok;*((int8_t*)(ptr + 0)) = 0;
    if ((*payload).is_some) {
      const extension_string_t *payload4 = &(*payload).val;
      *((int8_t*)(ptr + sizeof(void*))) = 1;
      *((size_t*)(ptr + (3*sizeof(void*)))) = (*payload4).len;
      *((uint8_t **)(ptr + (2*sizeof(void*)))) = (uint8_t *) (*payload4).ptr;
    } else {
      *((int8_t*)(ptr + sizeof(void*))) = 0;
    }
  }
  return ptr;
}

__attribute__((__export_name__("language-server-workspace-configuration")))
uint8_t * __wasm_export_exports_extension_language_server_workspace_configuration(uint8_t * arg, size_t arg0, int32_t arg1) {
  extension_string_t arg2 = (extension_string_t) { (uint8_t*)(arg), (arg0) };
  extension_result_option_string_string_t ret;
  extension_option_string_t ok;
  extension_string_t err;
  ret.is_err = !exports_extension_language_server_workspace_configuration(&arg2, (extension_borrow_worktree_t) { arg1 }, &ok, &err);
  if (ret.is_err) {
    ret.val.err = err;
  }
  if (!ret.is_err) {
    ret.val.ok = ok;
  }
  uint8_t *ptr = (uint8_t *) &RET_AREA;
  if ((ret).is_err) {
    const extension_string_t *payload5 = &(ret).val.err;*((int8_t*)(ptr + 0)) = 1;
    *((size_t*)(ptr + (2*sizeof(void*)))) = (*payload5).len;
    *((uint8_t **)(ptr + sizeof(void*))) = (uint8_t *) (*payload5).ptr;
  } else {
    const extension_option_string_t *payload = &(ret).val.ok;*((int8_t*)(ptr + 0)) = 0;
    if ((*payload).is_some) {
      const extension_string_t *payload4 = &(*payload).val;
      *((int8_t*)(ptr + sizeof(void*))) = 1;
      *((size_t*)(ptr + (3*sizeof(void*)))) = (*payload4).len;
      *((uint8_t **)(ptr + (2*sizeof(void*)))) = (uint8_t *) (*payload4).ptr;
    } else {
      *((int8_t*)(ptr + sizeof(void*))) = 0;
    }
  }
  return ptr;
}

__attribute__((__export_name__("language-server-additional-initialization-options")))
uint8_t * __wasm_export_exports_extension_language_server_additional_initialization_options(uint8_t * arg, size_t arg0, uint8_t * arg1, size_t arg2, int32_t arg3) {
  extension_string_t arg4 = (extension_string_t) { (uint8_t*)(arg), (arg0) };
  extension_string_t arg5 = (extension_string_t) { (uint8_t*)(arg1), (arg2) };
  extension_result_option_string_string_t ret;
  extension_option_string_t ok;
  extension_string_t err;
  ret.is_err = !exports_extension_language_server_additional_initialization_options(&arg4, &arg5, (extension_borrow_worktree_t) { arg3 }, &ok, &err);
  if (ret.is_err) {
    ret.val.err = err;
  }
  if (!ret.is_err) {
    ret.val.ok = ok;
  }
  uint8_t *ptr = (uint8_t *) &RET_AREA;
  if ((ret).is_err) {
    const extension_string_t *payload8 = &(ret).val.err;*((int8_t*)(ptr + 0)) = 1;
    *((size_t*)(ptr + (2*sizeof(void*)))) = (*payload8).len;
    *((uint8_t **)(ptr + sizeof(void*))) = (uint8_t *) (*payload8).ptr;
  } else {
    const extension_option_string_t *payload = &(ret).val.ok;*((int8_t*)(ptr + 0)) = 0;
    if ((*payload).is_some) {
      const extension_string_t *payload7 = &(*payload).val;
      *((int8_t*)(ptr + sizeof(void*))) = 1;
      *((size_t*)(ptr + (3*sizeof(void*)))) = (*payload7).len;
      *((uint8_t **)(ptr + (2*sizeof(void*)))) = (uint8_t *) (*payload7).ptr;
    } else {
      *((int8_t*)(ptr + sizeof(void*))) = 0;
    }
  }
  return ptr;
}

__attribute__((__export_name__("language-server-additional-workspace-configuration")))
uint8_t * __wasm_export_exports_extension_language_server_additional_workspace_configuration(uint8_t * arg, size_t arg0, uint8_t * arg1, size_t arg2, int32_t arg3) {
  extension_string_t arg4 = (extension_string_t) { (uint8_t*)(arg), (arg0) };
  extension_string_t arg5 = (extension_string_t) { (uint8_t*)(arg1), (arg2) };
  extension_result_option_string_string_t ret;
  extension_option_string_t ok;
  extension_string_t err;
  ret.is_err = !exports_extension_language_server_additional_workspace_configuration(&arg4, &arg5, (extension_borrow_worktree_t) { arg3 }, &ok, &err);
  if (ret.is_err) {
    ret.val.err = err;
  }
  if (!ret.is_err) {
    ret.val.ok = ok;
  }
  uint8_t *ptr = (uint8_t *) &RET_AREA;
  if ((ret).is_err) {
    const extension_string_t *payload8 = &(ret).val.err;*((int8_t*)(ptr + 0)) = 1;
    *((size_t*)(ptr + (2*sizeof(void*)))) = (*payload8).len;
    *((uint8_t **)(ptr + sizeof(void*))) = (uint8_t *) (*payload8).ptr;
  } else {
    const extension_option_string_t *payload = &(ret).val.ok;*((int8_t*)(ptr + 0)) = 0;
    if ((*payload).is_some) {
      const extension_string_t *payload7 = &(*payload).val;
      *((int8_t*)(ptr + sizeof(void*))) = 1;
      *((size_t*)(ptr + (3*sizeof(void*)))) = (*payload7).len;
      *((uint8_t **)(ptr + (2*sizeof(void*)))) = (uint8_t *) (*payload7).ptr;
    } else {
      *((int8_t*)(ptr + sizeof(void*))) = 0;
    }
  }
  return ptr;
}

__attribute__((__export_name__("labels-for-completions")))
uint8_t * __wasm_export_exports_extension_labels_for_completions(uint8_t * arg, size_t arg0, uint8_t * arg1, size_t arg2) {
  extension_string_t arg9 = (extension_string_t) { (uint8_t*)(arg), (arg0) };
  extension_list_completion_t arg10 = (extension_list_completion_t) { (extension_completion_t*)(arg1), (arg2) };
  extension_result_list_option_code_label_string_t ret;
  extension_list_option_code_label_t ok;
  extension_string_t err;
  ret.is_err = !exports_extension_labels_for_completions(&arg9, &arg10, &ok, &err);
  if (ret.is_err) {
    ret.val.err = err;
  }
  if (!ret.is_err) {
    ret.val.ok = ok;
  }
  uint8_t *ptr = (uint8_t *) &RET_AREA;
  if ((ret).is_err) {
    const extension_string_t *payload17 = &(ret).val.err;*((int8_t*)(ptr + 0)) = 1;
    *((size_t*)(ptr + (2*sizeof(void*)))) = (*payload17).len;
    *((uint8_t **)(ptr + sizeof(void*))) = (uint8_t *) (*payload17).ptr;
  } else {
    const extension_list_option_code_label_t *payload = &(ret).val.ok;*((int8_t*)(ptr + 0)) = 0;
    *((size_t*)(ptr + (2*sizeof(void*)))) = (*payload).len;
    *((uint8_t **)(ptr + sizeof(void*))) = (uint8_t *) (*payload).ptr;
  }
  return ptr;
}

__attribute__((__export_name__("labels-for-symbols")))
uint8_t * __wasm_export_exports_extension_labels_for_symbols(uint8_t * arg, size_t arg0, uint8_t * arg1, size_t arg2) {
  extension_string_t arg3 = (extension_string_t) { (uint8_t*)(arg), (arg0) };
  extension_list_symbol_t arg4 = (extension_list_symbol_t) { (extension_symbol_t*)(arg1), (arg2) };
  extension_result_list_option_code_label_string_t ret;
  extension_list_option_code_label_t ok;
  extension_string_t err;
  ret.is_err = !exports_extension_labels_for_symbols(&arg3, &arg4, &ok, &err);
  if (ret.is_err) {
    ret.val.err = err;
  }
  if (!ret.is_err) {
    ret.val.ok = ok;
  }
  uint8_t *ptr = (uint8_t *) &RET_AREA;
  if ((ret).is_err) {
    const extension_string_t *payload11 = &(ret).val.err;*((int8_t*)(ptr + 0)) = 1;
    *((size_t*)(ptr + (2*sizeof(void*)))) = (*payload11).len;
    *((uint8_t **)(ptr + sizeof(void*))) = (uint8_t *) (*payload11).ptr;
  } else {
    const extension_list_option_code_label_t *payload = &(ret).val.ok;*((int8_t*)(ptr + 0)) = 0;
    *((size_t*)(ptr + (2*sizeof(void*)))) = (*payload).len;
    *((uint8_t **)(ptr + sizeof(void*))) = (uint8_t *) (*payload).ptr;
  }
  return ptr;
}

// Ensure that the *_component_type.o object is linked in

extern void __component_type_object_force_link_extension(void);
void __component_type_object_force_link_extension_public_use_in_this_compilation_unit(void) {
  __component_type_object_force_link_extension();
}
